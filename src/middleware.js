import _ from 'lodash';
import { REDUX_EASY_ASYNC_NAMESPACE } from './lib/constants';

/**
 * Creates an instance of middleware necessary to handle dispatched async actions created with
 * {@link createAsyncAction}.
 * @kind function
 * @param  {object} options options to create middleware with.
 * @param {object} [options.requestOptions={}] options that will be passed to all action's
 * `makeRequest` functions: e.g. `makeRequest(state, requestOptions)`.
 * @param  {string} [options.namespace=REDUX_EASY_ASYNC_NAMESPACE] the action type the
 * middleware will listen for. You most likely don't want to modify this unless for some reason
 * you want multiple instances of async middleware.
 *
 * @return {function} redux middleware for handling async actions
 *
 * @example
 * import { createAsyncMiddleware } from 'redux-easy-async';
 * const asyncMiddleware = createAsyncMiddleware();
 *
 * ...
 *
 * // Now add to your middlewares whereever your store is created.
 * // Typically this looks something like:
 * // const middlewares = [asyncMiddleware, ...other middlewares]
 */
export const createAsyncMiddleware = (options = {}) => {
  const {
    namespace = REDUX_EASY_ASYNC_NAMESPACE,
    requestOptions,
  } = options;

  // Return Redux middleware
  return ({ dispatch, getState }) => next => (action) => {
    // Normal action: pass it on
    if (action.type !== namespace) return next(action);

    // configuration option defaults
    const {
      // actions to be dispatched before and on success/fail for request
      // generally auto-generated by createAsyncAction()
      startActionCreator,
      successActionCreator,
      failActionCreator,
      // generally auto-generated from createAsyncAction()
      actionName,
      // function that makes the actual request. Must return a promise.
      makeRequest,
      // additional meta that will be passed to the action if any - must be an object
      meta = {},
      // function that returns boolean for whether to proceed with the request.
      shouldMakeRequest = () => true,
      // on start the result of parse() is passed as the payload of the start action
      // This is useful for propagating params down
      parseStart = () => null,
      // on success the result of parse() is passed as the payload of the success action
      parseSuccess = resp => resp,
      // on fail the result of parseFail() is passed as the payload of the fail action
      parseFail = resp => resp,
    } = action;

    if (!shouldMakeRequest(getState())) return false;

    // create a unique ID for each request
    const asyncID = _.uniqueId('asyncID');
    // make the request and save the returned promise
    const req = makeRequest(getState(), requestOptions);
    // save the time the request was made
    const requestStartTime = Date.now();

    if (typeof _.get(req, 'then') !== 'function') {
      throw new Error(`makeRequest() for action "${actionName}" must return a promise.`);
    }

    dispatch(startActionCreator({
      payload: parseStart(),
      meta: {
        ...meta,
        actionName,
        asyncType: 'start',
        asyncID,
        requestStartTime,
      },
    }));

    req.then(
      resp => dispatch(successActionCreator({
        payload: parseSuccess(resp),
          // pass the response and actionName as part of the meta
        meta: {
          ...meta,
          actionName,
          asyncType: 'success',
          asyncID,
          requestStartTime,
          resp,
          requestDuration: Date.now() - requestStartTime,
        },
      })),
      resp => dispatch(failActionCreator({
        payload: parseFail(resp),
          // pass the response and actionName as part of the meta
        meta: {
          ...meta,
          actionName,
          asyncType: 'fail',
          asyncID,
          requestStartTime,
          resp,
          requestDuration: Date.now() - requestStartTime,
        },
      })),
      );
    return req;
  };
};
