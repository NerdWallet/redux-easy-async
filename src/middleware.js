import _ from 'lodash';
import { BASE_TYPE } from './lib/constants';

// Function to create a redux middleware to run async actions.
export const createAsyncMiddleware = (options) => {
  const {
    id = BASE_TYPE,
    requestOptions,
  } = options;

  // Return Redux middleware
  return ({ dispatch, getState }) => next => (action) => {
    // Normal action: pass it on
    if (action.type !== id) return next(action);

    // configuration option defaults
    const {
      // actions to be dispatched before and on success/fail for request
      // generally auto-generated by createAsyncAction()
      startActionCreator,
      successActionCreator,
      failActionCreator,
      // generally auto-generated from createAsyncAction()
      actionName,
      // function that makes the actual request. Must return a promise.
      makeRequest,
      // additional meta that will be passed to the action if any - must be an object
      meta = {},
      // function that returns boolean for whether to proceed with the request.
      shouldMakeRequest = () => true,
      // on start the result of parse() is passed as the payload of the start action
      // This is useful for propagating params down
      parseStart = () => null,
      // on success the result of parse() is passed as the payload of the success action
      parse = resp => resp,
      // on fail the result of parseFail() is passed as the payload of the fail action
      parseFail = resp => resp,
    } = action;


    if (!shouldMakeRequest(getState())) return false;

    dispatch(startActionCreator({
      payload: parseStart(),
      meta: {
        ...meta,
        actionName,
        asyncType: 'start',
      },
    }));

    const startTime = Date.now();

    const req = makeRequest(getState(), requestOptions);

    if (_.get(req, 'then') && typeof _.get(req, 'then') !== 'function') {
      throw new Error(`makeRequest() for action: "${actionName}" must return a promise.`);
    }

    req.then(
      resp => dispatch(successActionCreator({
        payload: parse(resp),
          // pass the response and actionName as part of the meta
        meta: {
          ...meta,
          resp,
          actionName,
          asyncType: 'success',
          requestTime: Date.now() - startTime,
        },
      })),
      resp => dispatch(failActionCreator({
        payload: parseFail(resp),
          // pass the response and actionName as part of the meta
        meta: {
          ...meta,
          resp,
          actionName,
          asyncType: 'fail',
          requestTime: Date.now() - startTime,
        },
      })),
      );
    return req;
  };
};
